{"remainingRequest":"/home/renu/admin/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/home/renu/admin/node_modules/@ngx-progressbar/core/esm5/ngx-progressbar-core.js","dependencies":[{"path":"/home/renu/admin/node_modules/@ngx-progressbar/core/esm5/ngx-progressbar-core.js","mtime":1513866874000},{"path":"/home/renu/admin/node_modules/cache-loader/dist/cjs.js","mtime":0},{"path":"/home/renu/admin/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["import { ChangeDetectionStrategy, Component, Injectable, Input, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { Subject as Subject$1 } from 'rxjs/Subject';\nimport { BehaviorSubject as BehaviorSubject$1 } from 'rxjs/BehaviorSubject';\nimport { timer as timer$1 } from 'rxjs/observable/timer';\nimport { distinctUntilChanged, filter, map, skip, switchMap, takeWhile, tap } from 'rxjs/operators';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Keep value within the range\n */\nvar clamp = function (n, min, max) {\n    if (n < min) {\n        return min;\n    }\n    if (n > max) {\n        return max;\n    }\n    return n;\n};\nvar NgProgress = /*@__PURE__*/ (function () {\n    function NgProgress() {\n        var _this = this;\n        /**\n         * Initial state\n         */\n        this.initState = {\n            active: false,\n            value: 0\n        };\n        /**\n         * Progress state\n         */\n        this.state$ = new BehaviorSubject$1(this.initState);\n        /**\n         * Trickling stream\n         */\n        this.trickling$ = new Subject$1();\n        this.progress = 0;\n        this.maximum = 1;\n        this.minimum = 0.08;\n        this.speed = 200;\n        this.trickleSpeed = 300;\n        this.trickling$.pipe(switchMap(function () { return timer$1(0, _this.trickleSpeed).pipe(takeWhile(function () { return _this.isStarted; }), tap(function () { return _this.inc(); })); })).subscribe();\n    }\n    Object.defineProperty(NgProgress.prototype, \"isStarted\", {\n        /**\n         * Is progress started\n         * @return {?}\n         */\n        get: function () {\n            return this.progress > 0 && this.progress < this.maximum;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgProgress.prototype, \"started\", {\n        /**\n         * Progress start event\n         * @return {?}\n         */\n        get: function () {\n            return this.state$.pipe(map(function (state) { return state.active; }), distinctUntilChanged(), filter(function (active) { return active; }));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgProgress.prototype, \"ended\", {\n        /**\n         * Progress ended event\n         * @return {?}\n         */\n        get: function () {\n            return this.state$.pipe(map(function (state) { return state.active; }), distinctUntilChanged(), filter(function (active) { return !active; }), skip(1));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Start\n     * @return {?}\n     */\n    NgProgress.prototype.start = function () {\n        if (!this.isStarted) {\n            this.set(this.minimum);\n        }\n        this.trickling$.next();\n    };\n    /**\n     * Done\n     * @return {?}\n     */\n    NgProgress.prototype.done = function () {\n        /** if started, complete the progress */\n        if (this.isStarted) {\n            this.set(.3 + .5 * Math.random());\n            this.set(this.maximum);\n        }\n    };\n    /**\n     * Increment the progress\n     * @param {?=} amount\n     * @return {?}\n     */\n    NgProgress.prototype.inc = function (amount) {\n        var /** @type {?} */ n = this.progress;\n        /** if it hasn't start, start */\n        if (!this.isStarted) {\n            this.start();\n        }\n        else {\n            if (typeof amount !== 'number') {\n                if (n >= 0 && n < 0.2) {\n                    amount = 0.1;\n                }\n                else if (n >= 0.2 && n < 0.5) {\n                    amount = 0.04;\n                }\n                else if (n >= 0.5 && n < 0.8) {\n                    amount = 0.02;\n                }\n                else if (n >= 0.8 && n < 0.99) {\n                    amount = 0.005;\n                }\n                else {\n                    amount = 0;\n                }\n            }\n            n = clamp(n + amount, 0, 0.994);\n            this.set(n);\n        }\n    };\n    /**\n     * Set the progress\n     * @param {?} n - Progress value\n     * @return {?}\n     */\n    NgProgress.prototype.set = function (n) {\n        var _this = this;\n        this.progress = clamp(n, this.minimum, this.maximum);\n        this.updateState(this.progress, true);\n        /** if progress completed */\n        if (n === this.maximum) {\n            var /** @type {?} */ hide_1 = function () {\n                /**\n                         *  reset the progress\n                         *  Keep it { 0, false } to fadeOut progress-bar after complete\n                         */\n                if (_this.progress >= _this.maximum) {\n                    _this.progress = 0;\n                    _this.updateState(_this.progress, false);\n                }\n            };\n            var /** @type {?} */ complete = function () {\n                /**\n                         * complete the progress\n                         * { 1, false } to complete progress-bar before hiding\n                         */\n                if (_this.progress >= _this.maximum) {\n                    _this.updateState(_this.progress, false);\n                    setTimeout(hide_1, _this.speed);\n                }\n            };\n            setTimeout(complete, this.speed);\n        }\n    };\n    /**\n     * Update progress state\n     * @param {?} progress - Progress value\n     * @param {?} isActive - Progress active\n     * @return {?}\n     */\n    NgProgress.prototype.updateState = function (progress, isActive) {\n        this.state$.next({\n            active: isActive,\n            value: progress\n        });\n    };\n    return NgProgress;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @record\n */\nvar NgProgressBarComponent = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} progress\n     */\n    function NgProgressBarComponent(progress) {\n        this.progress = progress;\n    }\n    /**\n     * @return {?}\n     */\n    NgProgressBarComponent.prototype.ngOnInit = function () {\n        var _this = this;\n        this.state$ = this.progress.state$.pipe(map(function (state) {\n            return ({\n                containerClasses: _this.containerClasses(state),\n                progressStyles: _this.progressBarStyles(state),\n                spinnerClasses: _this.spinnerClasses(),\n                spinnerStyles: _this.spinnerStyles(),\n                meteorStyles: _this.meteor ? _this.meteorStyles() : null\n            });\n        }));\n    };\n    /**\n     * @param {?} state\n     * @return {?}\n     */\n    NgProgressBarComponent.prototype.containerClasses = function (state) {\n        return {\n            active: state.active,\n            thick: this.thick\n        };\n    };\n    /**\n     * @param {?} state\n     * @return {?}\n     */\n    NgProgressBarComponent.prototype.progressBarStyles = function (state) {\n        var /** @type {?} */ n = (!state.value) ? directionSwitcher[this.direction].bar : this.toPercentage(state.value);\n        var /** @type {?} */ translate3d = \"translate3d(\" + n + \"%,0,0)\";\n        return {\n            transition: \"all \" + this.speed + \"ms \" + this.ease,\n            background: this.color,\n            msTransform: translate3d,\n            webkitTransform: translate3d,\n            transform: translate3d\n        };\n    };\n    /**\n     * Styles for progressbar tail\n     * @return {?}\n     */\n    NgProgressBarComponent.prototype.meteorStyles = function () {\n        return {\n            boxShadow: \"0 0 10px \" + this.color + \", 0 0 5px \" + this.color,\n            left: directionSwitcher[this.direction].meteorLeft,\n            transform: directionSwitcher[this.direction].meteorRotate(this.thick),\n        };\n    };\n    /**\n     * Convert number to percent\n     * @param {?} n - State value\n     * @return {?}\n     */\n    NgProgressBarComponent.prototype.toPercentage = function (n) {\n        return directionSwitcher[this.direction].toPercentage(n) * 100;\n    };\n    /**\n     * Spinner direction\n     * @return {?}\n     */\n    NgProgressBarComponent.prototype.spinnerClasses = function () {\n        return directionSwitcher[this.direction].spinnerClass + ' spinner-' + this.spinnerPosition;\n    };\n    /**\n     * Spinner styles\n     * @return {?}\n     */\n    NgProgressBarComponent.prototype.spinnerStyles = function () {\n        return {\n            borderTopColor: this.color,\n            borderLeftColor: this.color\n        };\n    };\n    return NgProgressBarComponent;\n}());\nvar ɵ0 = function (n) { return -1 + n; };\nvar ɵ1 = function (thick) { return \"rotate(\" + (thick ? 4 : 3) + \"deg)\"; };\nvar ɵ2 = function (n) { return -n; };\nvar ɵ3 = function (thick) { return \"rotate(\" + (thick ? 4 : 3) + \"deg)\"; };\nvar ɵ4 = function (n) { return 1 - n; };\nvar ɵ5 = function (thick) { return \"rotate(\" + (thick ? -4 : -3) + \"deg)\"; };\nvar ɵ6 = function (n) { return n; };\nvar ɵ7 = function (thick) { return \"rotate(\" + (thick ? -4 : -3) + \"deg)\"; };\nvar directionSwitcher = {\n    leftToRightIncreased: {\n        bar: -100,\n        toPercentage: ɵ0,\n        spinnerClass: 'clockwise',\n        meteorRotate: ɵ1,\n        meteorLeft: 'unset'\n    },\n    leftToRightReduced: {\n        bar: 0,\n        toPercentage: ɵ2,\n        spinnerClass: 'anti-clockwise',\n        meteorRotate: ɵ3,\n        meteorLeft: 'unset'\n    },\n    rightToLeftIncreased: {\n        bar: 100,\n        toPercentage: ɵ4,\n        spinnerClass: 'anti-clockwise',\n        meteorRotate: ɵ5,\n        meteorLeft: 0\n    },\n    rightToLeftReduced: {\n        bar: 0,\n        toPercentage: ɵ6,\n        spinnerClass: 'clockwise',\n        meteorRotate: ɵ7,\n        meteorLeft: 0\n    }\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar NgProgressComponent = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} progress\n     */\n    function NgProgressComponent(progress) {\n        this.progress = progress;\n        /**\n         * Progress options\n         */\n        this.ease = 'linear';\n        this.meteor = true;\n        this.spinner = true;\n        this.spinnerPosition = 'right';\n        this.direction = 'leftToRightIncreased';\n        this.color = '#1B95E0';\n        this.thick = false;\n        this.maximum = 1;\n        this.minimum = 0.08;\n        this.speed = 200;\n        this.trickleSpeed = 300;\n    }\n    Object.defineProperty(NgProgressComponent.prototype, \"toggleProgressbar\", {\n        /**\n         * Start/Stop Progressbar\n         * @param {?} toggle\n         * @return {?}\n         */\n        set: function (toggle) {\n            toggle ? this.progress.start() : this.progress.done();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    NgProgressComponent.prototype.ngOnChanges = function (changes) {\n        var /** @type {?} */ minChng = changes[\"minimum\"];\n        var /** @type {?} */ maxChng = changes[\"maximum\"];\n        var /** @type {?} */ spdChng = changes[\"speed\"];\n        var /** @type {?} */ tklSpdChng = changes[\"trickleSpeed\"];\n        if (minChng) {\n            if (typeof minChng.currentValue !== 'undefined' && minChng.currentValue !== minChng.previousValue) {\n                if (minChng.currentValue < 0 || minChng.currentValue > 1) {\n                    throw new Error('Input [minimum] must be between 0 and 1');\n                }\n                else {\n                    this.progress.minimum = minChng.currentValue;\n                }\n            }\n        }\n        if (maxChng) {\n            if (typeof maxChng.currentValue !== 'undefined' && maxChng.currentValue !== maxChng.previousValue) {\n                if (maxChng.currentValue < 0 || maxChng.currentValue > 1) {\n                    throw new Error('Input [maximum] must be between 0 and 1');\n                }\n                else {\n                    this.progress.maximum = maxChng.currentValue;\n                }\n            }\n        }\n        if (spdChng) {\n            if (typeof spdChng.currentValue !== 'undefined' && spdChng.currentValue !== spdChng.previousValue) {\n                this.progress.speed = spdChng.currentValue;\n            }\n        }\n        if (tklSpdChng) {\n            if (typeof tklSpdChng.currentValue !== 'undefined' && tklSpdChng.currentValue !== tklSpdChng.previousValue) {\n                this.progress.trickleSpeed = tklSpdChng.currentValue;\n            }\n        }\n    };\n    return NgProgressComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar NgProgressModule = /*@__PURE__*/ (function () {\n    function NgProgressModule() {\n    }\n    /**\n     * @return {?}\n     */\n    NgProgressModule.forRoot = function () {\n        return {\n            ngModule: NgProgressModule,\n            providers: [NgProgress]\n        };\n    };\n    return NgProgressModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\nexport { NgProgressModule, NgProgress, NgProgressBarComponent as ɵb, NgProgressComponent as ɵa };\n//# sourceMappingURL=ngx-progressbar-core.js.map\n",null]}